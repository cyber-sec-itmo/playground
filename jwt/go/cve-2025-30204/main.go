package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"net/http"
	"net/url"
	"os"
	"os/signal"
	"runtime/debug"
	"strconv"
	"strings"
	"syscall"
	"time"

	_ "net/http/pprof"

	"github.com/golang-jwt/jwt/v4"
	"github.com/google/uuid"
	_ "github.com/mattn/go-sqlite3"
)

const (
	DefaultDatabaseSqliteURI = "jwtgo.sqlite"

	DefaultServerAddr = "localhost"
	DefaultServerPort = "8080"

	DefaultJWTSecret = "00000000-0000-0000-1000-000000000000"
)

// --- DATA STRUCTURE ---

// Token represents a JWT token
type Token struct {
	ID        string    `json:"id"` // jti (UUID)
	IsRevoked bool      `json:"is_revoked"`
	IssuedAt  time.Time `json:"issued_at"`
	ExpiresAt time.Time `json:"expires_at"`
	UpdatedAt time.Time `json:"updated_at"`
	ClientIP  string    `json:"client_ip"`
	UserAgent string    `json:"user_agent"`

	// Optional audit fields:
	Token string `json:"token,omitempty"` // jwt full token string
}

// TokenUsage represents a single usage event for a token
type TokenUsage struct {
	ID        int64     `json:"id"`
	TokenID   string    `json:"token_id"`
	TS        time.Time `json:"ts"`
	ClientIP  string    `json:"client_ip"`
	UserAgent string    `json:"user_agent"`
	Method    string    `json:"method"`
	Status    int       `json:"status"`
}

// --- DATABASE ---

// SqliteDB represents a SQLite database connection
type SqliteDB struct {
	db *sql.DB
}

// NewSqliteDB creates a new SQLite database connection with specified options
func NewSqliteDB(uri string, enableWal bool, syncPragma string) (*SqliteDB, error) {
	params := url.Values{}
	params.Add("_synchronous", "NORMAL")
	params.Add("_journal_mode", "WAL")

	constructedUri := uri
	if len(params) > 0 {
		if strings.Contains(uri, "?") {
			constructedUri += "&" + params.Encode()
		} else {
			constructedUri += "?" + params.Encode()
		}
	}

	db, err := sql.Open("sqlite3", constructedUri)
	if err != nil {
		return nil, fmt.Errorf("failed to open database with DSN '%s': %w", constructedUri, err)
	}

	// Configure connection pool settings
	db.SetMaxOpenConns(1) // SQLite only supports one writer at a time
	db.SetMaxIdleConns(1)
	db.SetConnMaxLifetime(time.Hour)

	// Enable foreign key support for this connection.
	// This is crucial for ON DELETE CASCADE and other FK actions to work.
	_, err = db.Exec("PRAGMA foreign_keys = ON;")
	if err != nil {
		db.Close() // Close DB if we can't set the pragma
		return nil, fmt.Errorf("failed to enable foreign key support for DSN '%s': %w", constructedUri, err)
	}

	return &SqliteDB{db: db}, nil
}

// RunMigrations applies migrations to the database
func (s *SqliteDB) RunMigrations(ctx context.Context) error {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	m1 := `CREATE TABLE IF NOT EXISTS tokens (
		id          TEXT PRIMARY KEY,
		is_revoked  INTEGER NOT NULL,
		issued_at   TEXT NOT NULL,
		expires_at  TEXT NOT NULL,
		updated_at  TEXT NOT NULL,
		client_ip   TEXT,
		user_agent 	TEXT
	);`

	m2 := `CREATE TABLE IF NOT EXISTS token_usages (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		token_id TEXT NOT NULL,
		ts INTEGER NOT NULL,
		client_ip   TEXT,
		user_agent 	TEXT,
		method TEXT,
		status INTEGER,
		FOREIGN KEY (token_id) REFERENCES tokens(id) ON DELETE CASCADE
	);
	CREATE INDEX IF NOT EXISTS idx_usage_token_ts ON token_usages(token_id, ts);`

	// Run migrations sequentially
	if _, err := s.db.ExecContext(ctx, m1); err != nil {
		return fmt.Errorf("failed to run migration m1: %w", err)
	}

	if _, err := s.db.ExecContext(ctx, m2); err != nil {
		return fmt.Errorf("failed to run migration m2: %w", err)
	}

	return nil
}

// TestConnection tests the database connection with a timeout
func (s *SqliteDB) TestConnection(ctx context.Context) error {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	return s.db.PingContext(ctx)
}

// Close closes the database connection
func (s *SqliteDB) Close() error {
	if s.db != nil {
		return s.db.Close()
	}
	return nil
}

// parseTokenFromDb fills a Token struct from database row values
func parseTokenFromDb(token *Token, isRevokedInt int, issuedAtStr, expiresAtStr, updatedAtStr string, clientIP, userAgent sql.NullString) error {
	// Convert INTEGER to boolean
	token.IsRevoked = isRevokedInt != 0

	// Parse Unix timestamps to time.Time
	issuedAtUnix, err := strconv.ParseInt(issuedAtStr, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse issued_at: %w", err)
	}
	token.IssuedAt = time.Unix(issuedAtUnix, 0)

	expiresAtUnix, err := strconv.ParseInt(expiresAtStr, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse expires_at: %w", err)
	}
	token.ExpiresAt = time.Unix(expiresAtUnix, 0)

	updatedAtUnix, err := strconv.ParseInt(updatedAtStr, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse updated_at: %w", err)
	}
	token.UpdatedAt = time.Unix(updatedAtUnix, 0)

	// Set client_ip and user_agent
	token.ClientIP = clientIP.String
	token.UserAgent = userAgent.String

	return nil
}

func (s *SqliteDB) ListTokens(ctx context.Context) ([]Token, error) {
	query := "SELECT id, is_revoked, issued_at, expires_at, updated_at, client_ip, user_agent FROM tokens ORDER BY updated_at"

	rows, err := s.db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to query tokens: %w", err)
	}
	defer rows.Close()

	tokens := []Token{}
	for rows.Next() {
		var token Token
		var issuedAtStr, expiresAtStr, updatedAtStr string
		var isRevokedInt int
		var clientIP, userAgent sql.NullString

		err := rows.Scan(&token.ID, &isRevokedInt, &issuedAtStr, &expiresAtStr, &updatedAtStr, &clientIP, &userAgent)
		if err != nil {
			return nil, fmt.Errorf("failed to scan token row: %w", err)
		}

		if err := parseTokenFromDb(&token, isRevokedInt, issuedAtStr, expiresAtStr, updatedAtStr, clientIP, userAgent); err != nil {
			return nil, err
		}

		tokens = append(tokens, token)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating token rows: %w", err)
	}

	return tokens, nil
}

// CreateToken creates a new token record in the database
func (s *SqliteDB) CreateToken(ctx context.Context, token Token) error {
	query := `
	INSERT INTO tokens (
	    id, is_revoked, issued_at, expires_at, updated_at, client_ip, user_agent
	) VALUES (?, ?, ?, ?, ?, ?, ?);
	`

	isRevokedInt := 0
	if token.IsRevoked {
		isRevokedInt = 1
	}

	_, err := s.db.ExecContext(
		ctx,
		query,
		token.ID,
		isRevokedInt,
		token.IssuedAt.Unix(),
		token.ExpiresAt.Unix(),
		token.UpdatedAt.Unix(),
		token.ClientIP,
		token.UserAgent,
	)
	if err != nil {
		return fmt.Errorf("CreateToken: failed to insert: %w", err)
	}
	return nil
}

// GetTokenByID retrieves a token by its ID from the database
func (s *SqliteDB) GetTokenByID(ctx context.Context, tokenID string) (*Token, error) {
	query := "SELECT id, is_revoked, issued_at, expires_at, updated_at, client_ip, user_agent FROM tokens WHERE id = ?"

	var token Token
	var issuedAtStr, expiresAtStr, updatedAtStr string
	var isRevokedInt int
	var clientIP, userAgent sql.NullString

	err := s.db.QueryRowContext(ctx, query, tokenID).Scan(
		&token.ID,
		&isRevokedInt,
		&issuedAtStr,
		&expiresAtStr,
		&updatedAtStr,
		&clientIP,
		&userAgent,
	)
	if err == sql.ErrNoRows {
		return nil, nil // Token not found
	}
	if err != nil {
		return nil, fmt.Errorf("failed to query token: %w", err)
	}

	if err := parseTokenFromDb(&token, isRevokedInt, issuedAtStr, expiresAtStr, updatedAtStr, clientIP, userAgent); err != nil {
		return nil, err
	}

	return &token, nil
}

// CreateTokenUsage creates a new token usage record in the database
func (s *SqliteDB) CreateTokenUsage(ctx context.Context, tokenID string, ts int64, clientIP, userAgent, method string, status int) error {
	query := `
	INSERT INTO token_usages (
	    token_id, ts, client_ip, user_agent, method, status
	) VALUES (?, ?, ?, ?, ?, ?);
	`

	_, err := s.db.ExecContext(
		ctx,
		query,
		tokenID,
		ts,
		clientIP,
		userAgent,
		method,
		status,
	)
	if err != nil {
		return fmt.Errorf("CreateTokenUsage: failed to insert: %w", err)
	}
	return nil
}

// RevokeToken marks a token as revoked in the database and returns the updated token
func (s *SqliteDB) RevokeToken(ctx context.Context, tokenID string) (*Token, error) {
	query := `
	UPDATE tokens 
	SET is_revoked = 1, updated_at = ?
	WHERE id = ?
	RETURNING id, is_revoked, issued_at, expires_at, updated_at, client_ip, user_agent;
	`

	now := time.Now()
	var token Token
	var issuedAtStr, expiresAtStr, updatedAtStr string
	var isRevokedInt int
	var clientIP, userAgent sql.NullString

	err := s.db.QueryRowContext(
		ctx,
		query,
		now.Unix(),
		tokenID,
	).Scan(
		&token.ID,
		&isRevokedInt,
		&issuedAtStr,
		&expiresAtStr,
		&updatedAtStr,
		&clientIP,
		&userAgent,
	)
	if err == sql.ErrNoRows {
		return nil, sql.ErrNoRows // Token not found
	}
	if err != nil {
		return nil, fmt.Errorf("RevokeToken: failed to update: %w", err)
	}

	if err := parseTokenFromDb(&token, isRevokedInt, issuedAtStr, expiresAtStr, updatedAtStr, clientIP, userAgent); err != nil {
		return nil, err
	}

	return &token, nil
}

// ListTokenUsage returns usage events for a given token ID ordered by timestamp descending
func (s *SqliteDB) ListTokenUsage(ctx context.Context, tokenID string) ([]TokenUsage, error) {
	query := `
	SELECT id, token_id, ts, client_ip, user_agent, method, status
	FROM token_usages
	WHERE token_id = ?
	ORDER BY ts DESC`

	rows, err := s.db.QueryContext(ctx, query, tokenID)
	if err != nil {
		return nil, fmt.Errorf("ListTokenUsage: failed to query: %w", err)
	}
	defer rows.Close()

	usages := []TokenUsage{}
	for rows.Next() {
		var usage TokenUsage
		var tsInt int64
		var clientIP, userAgent, method sql.NullString

		if err := rows.Scan(&usage.ID, &usage.TokenID, &tsInt, &clientIP, &userAgent, &method, &usage.Status); err != nil {
			return nil, fmt.Errorf("ListTokenUsage: failed to scan row: %w", err)
		}

		usage.TS = time.Unix(tsInt, 0)
		usage.ClientIP = clientIP.String
		usage.UserAgent = userAgent.String
		usage.Method = method.String

		usages = append(usages, usage)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("ListTokenUsage: row iteration error: %w", err)
	}

	return usages, nil
}

// --- SERVER ---

// Server holds server state and dependencies
type Server struct {
	SDB       SqliteDB
	JWTSecret []byte
}

// collectClientInfo extracts client IP and user agent from request
func collectClientInfo(r *http.Request) (clientIP, userAgent string) {
	// Extract IP address
	clientIP = r.Header.Get("X-Forwarded-For")
	if clientIP == "" {
		ip, _, err := net.SplitHostPort(r.RemoteAddr)
		if err != nil {
			clientIP = r.RemoteAddr
		} else {
			clientIP = ip
		}
	} else {
		// X-Forwarded-For can contain multiple IPs, take the first one
		ips := strings.Split(clientIP, ",")
		clientIP = strings.TrimSpace(ips[0])
	}

	// Extract user agent
	userAgent = r.UserAgent()

	return clientIP, userAgent
}

// Handle panic errors to prevent server shutdown
func (s *Server) panicMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				fmt.Printf("panicMiddleware, error: %v", err)
				http.Error(w, "Internal server error", 500)
			}
		}()
		// There will be a defer with panic handler in each next function
		next.ServeHTTP(w, r)
	})
}

// Log access requests in proper format
func (s *Server) logMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		next.ServeHTTP(w, r)

		// Extract client info
		ip, userAgent := collectClientInfo(r)

		// Build full URL (path + query)
		fullURL := r.URL.Path
		if r.URL.RawQuery != "" {
			fullURL += "?" + r.URL.RawQuery
		}

		// Log with all information
		log.Printf("%s %s %s user_agent=%s\n", ip, r.Method, fullURL, userAgent)
	})
}

// parseJWTToken parses JWT token string and returns token, claims, and jti
func (s *Server) parseJWTToken(tokenString string) (*jwt.Token, jwt.MapClaims, string, error) {
	if tokenString == "" {
		return nil, nil, "", fmt.Errorf("empty token string")
	}

	// Parse JWT token
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		// Validate signing method
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return s.JWTSecret, nil
	})

	if err != nil {
		return nil, nil, "", err
	}

	if !token.Valid {
		return nil, nil, "", fmt.Errorf("invalid token")
	}

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		return nil, nil, "", fmt.Errorf("invalid token claims")
	}

	jti, ok := claims["jti"].(string)
	if !ok {
		return nil, nil, "", fmt.Errorf("missing jti in token claims")
	}

	return token, claims, jti, nil
}

// parseJWTTokenUnverified CVE-2025-30204
func (s *Server) parseJWTTokenUnverified(tokenString string) (*jwt.Token, jwt.MapClaims, string, error) {
	if tokenString == "" {
		return nil, nil, "", fmt.Errorf("empty token string")
	}

	// Parse JWT token without verification
	claims := jwt.MapClaims{}
	parser := &jwt.Parser{}
	token, _, err := parser.ParseUnverified(tokenString, claims)

	if err != nil {
		return nil, nil, "", err
	}

	// ParseUnverified doesn't set token.Valid, so we use the claims directly
	// claims is already populated by ParseUnverified

	jti, ok := claims["jti"].(string)
	if !ok {
		return nil, nil, "", fmt.Errorf("missing jti in token claims")
	}

	return token, claims, jti, nil
}

// Ping handles the ping-pong endpoint
func (s *Server) Ping(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("pong"))
}

// Version handles the version endpoint and returns the JWT library version
func (s *Server) Version(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Read build info to get module versions
	buildInfo, ok := debug.ReadBuildInfo()
	if !ok {
		http.Error(w, "Failed to read build info", http.StatusInternalServerError)
		return
	}

	// Find the jwt/v4 module in dependencies
	jwtVersion := "unknown"
	for _, dep := range buildInfo.Deps {
		if dep.Path == "github.com/golang-jwt/jwt/v4" {
			jwtVersion = dep.Version
			break
		}
	}

	w.Header().Set("Content-Type", "text/plain")
	w.WriteHeader(http.StatusOK)
	fmt.Fprintf(w, "%s\n", jwtVersion)
}

// Tokens returns list of tokens from database
func (s *Server) Tokens(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	tokens, err := s.SDB.ListTokens(r.Context())
	if err != nil {
		log.Printf("Tokens, error: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(tokens); err != nil {
		log.Printf("Tokens, error encoding response: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}
}

// TokensAuth creates a new JWT token and stores it in the database (imitation of sign-up/login)
func (s *Server) TokensAuth(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	if err := r.ParseForm(); err != nil {
		http.Error(w, "Failed to parse the form", http.StatusBadGateway)
		return
	}

	expSecStr := r.FormValue("expires_sec")
	expDuration := 24 * time.Hour // default 24 hours
	if expSecStr != "" {
		if expSec, err := strconv.ParseInt(expSecStr, 10, 64); err == nil {
			expDuration = time.Duration(expSec) * time.Second
		} else {
			http.Error(w, "Invalid expires_sec parameter", http.StatusBadRequest)
			return
		}
	}

	// Setup token
	now := time.Now()
	expiresAt := now.Add(expDuration)
	tokenID := uuid.New()

	// Create JWT claims
	claims := jwt.MapClaims{
		"jti": tokenID,          // JWT ID
		"iat": now.Unix(),       // Issued at
		"exp": expiresAt.Unix(), // Expiration time
		"nbf": now.Unix(),       // Not before
	}

	// Create token
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	// Sign token with secret
	tokenString, err := token.SignedString(s.JWTSecret)
	if err != nil {
		log.Printf("SignUp, error signing token: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	// Collect client info for replay analysis
	clientIP, userAgent := collectClientInfo(r)

	t := Token{
		ID:        tokenID.String(),
		IsRevoked: false,
		IssuedAt:  now,
		ExpiresAt: expiresAt,
		UpdatedAt: now,
		ClientIP:  clientIP,
		UserAgent: userAgent,

		Token: tokenString,
	}

	// Store token in database
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	if err := s.SDB.CreateToken(ctx, t); err != nil {
		log.Printf("SignUp, error storing token: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	// Record token usage (creation)
	if err := s.SDB.CreateTokenUsage(ctx, t.ID, now.Unix(), clientIP, r.UserAgent(), r.Method, http.StatusCreated); err != nil {
		log.Printf("TokensAuth, error recording token usage: %v", err)
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(t); err != nil {
		log.Printf("SignUp, error encoding response: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}
}

// TokensValidate checks the token valid status
func (s *Server) TokensValidate(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	auth := r.Header.Get("Authorization")
	tokenString := strings.TrimPrefix(auth, "Bearer ")
	if tokenString == "" {
		http.Error(w, "Missing token parameter", http.StatusBadRequest)
		return
	}

	// Parse and validate JWT token
	_, _, jti, err := s.parseJWTToken(tokenString)
	if err != nil {
		http.Error(w, "Invalid token", http.StatusUnauthorized)
		return
	}

	// Check if token is revoked in database
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	dbToken, err := s.SDB.GetTokenByID(ctx, jti)
	if err != nil {
		log.Printf("TokensValidate, error querying token: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	// If token not found in database, consider it invalid
	if dbToken == nil {
		http.Error(w, "Token not found", http.StatusUnauthorized)
		return
	}

	// Collect client info for usage tracking
	clientIP, userAgent := collectClientInfo(r)

	// Check if token is revoked
	if dbToken.IsRevoked {
		http.Error(w, "Token revoked", http.StatusForbidden)
		return
	}

	// Record token usage
	now := time.Now()
	if err := s.SDB.CreateTokenUsage(ctx, jti, now.Unix(), clientIP, userAgent, r.Method, http.StatusOK); err != nil {
		log.Printf("TokensValidate, error recording token usage: %v", err)
		// Don't fail the request if usage recording fails, just log it
	}

	// Token is valid and not revoked, return full token
	dbToken.Token = tokenString

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(dbToken); err != nil {
		log.Printf("TokensValidate, error encoding response: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}
}

// TokensValidateUnverified CVE-2025-30204
func (s *Server) TokensValidateUnverified(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	auth := r.Header.Get("Authorization")
	tokenString := strings.TrimPrefix(auth, "Bearer ")
	if tokenString == "" {
		http.Error(w, "Missing token parameter", http.StatusBadRequest)
		return
	}

	// Parse and validate JWT token
	_, _, jti, err := s.parseJWTTokenUnverified(tokenString)
	if err != nil {
		http.Error(w, "Invalid token", http.StatusUnauthorized)
		return
	}

	// Check if token is revoked in database
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	dbToken, err := s.SDB.GetTokenByID(ctx, jti)
	if err != nil {
		log.Printf("TokensValidate, error querying token: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	// If token not found in database, consider it invalid
	if dbToken == nil {
		http.Error(w, "Token not found", http.StatusUnauthorized)
		return
	}

	// Collect client info for usage tracking
	clientIP, userAgent := collectClientInfo(r)

	// Check if token is revoked
	if dbToken.IsRevoked {
		http.Error(w, "Token revoked", http.StatusForbidden)
		return
	}

	// Record token usage
	now := time.Now()
	if err := s.SDB.CreateTokenUsage(ctx, jti, now.Unix(), clientIP, userAgent, r.Method, http.StatusOK); err != nil {
		log.Printf("TokensValidate, error recording token usage: %v", err)
		// Don't fail the request if usage recording fails, just log it
	}

	// Token is valid and not revoked, return full token
	dbToken.Token = tokenString

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(dbToken); err != nil {
		log.Printf("TokensValidate, error encoding response: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}
}

// TokensUsage returns usage of exact token
func (s *Server) TokensUsage(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	tokenParam := r.URL.Query().Get("token")
	if tokenParam == "" {
		http.Error(w, "Missing token parameter", http.StatusBadRequest)
		return
	}

	_, _, tokenID, err := s.parseJWTToken(tokenParam)
	if err != nil {
		http.Error(w, "Invalid token", http.StatusUnauthorized)
		return
	}

	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	usages, err := s.SDB.ListTokenUsage(ctx, tokenID)
	if err != nil {
		log.Printf("TokensUsage, error querying usages: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(usages); err != nil {
		log.Printf("TokensUsage, error encoding response: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}
}

// TokensRevoke invalidates the token
func (s *Server) TokensRevoke(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodDelete {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Get token from query parameter
	tokenString := r.URL.Query().Get("token")
	if tokenString == "" {
		http.Error(w, "Missing token parameter", http.StatusBadRequest)
		return
	}

	// Parse JWT token to extract jti
	_, _, tokenID, err := s.parseJWTToken(tokenString)
	if err != nil {
		http.Error(w, "Invalid token", http.StatusUnauthorized)
		return
	}

	// Revoke token in database
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	token, err := s.SDB.RevokeToken(ctx, tokenID)
	if err != nil {
		if err == sql.ErrNoRows {
			http.Error(w, "Token not found", http.StatusNotFound)
			return
		}
		log.Printf("TokensRevoke, error revoking token: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	// Collect client info for usage tracking
	clientIP, userAgent := collectClientInfo(r)

	// Record token usage
	now := time.Now()
	if err := s.SDB.CreateTokenUsage(ctx, tokenID, now.Unix(), clientIP, userAgent, r.Method, http.StatusOK); err != nil {
		log.Printf("TokensRevoke, error recording token usage: %v", err)
		// Don't fail the request if usage recording fails, just log it
	}

	// Return the revoked token
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	if err := json.NewEncoder(w).Encode(token); err != nil {
		log.Printf("TokensRevoke, error encoding response: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}
}

// --- MAIN ENTRYPOINT ---

func main() {
	dbUri := os.Getenv("DATABASE_URI")
	if dbUri == "" {
		dbUri = DefaultDatabaseSqliteURI
	}

	serverAddr := os.Getenv("SERVER_ADDR")
	if serverAddr == "" {
		serverAddr = DefaultServerAddr
	}

	serverPort := os.Getenv("SERVER_PORT")
	if serverPort == "" {
		serverPort = DefaultServerPort
	} else {
		if _, err := strconv.Atoi(serverPort); err != nil {
			fmt.Printf("Invalid port: %s, must be a number", serverPort)
			os.Exit(1)
		}
	}

	// Initialize database connection using registry
	fmt.Println("Initializing database connection")
	database, err := NewSqliteDB(dbUri, true, "NORMAL")
	if err != nil {
		fmt.Printf("Failed to initialize database connection, error: %v", err)
		os.Exit(1)
	}

	// Test database connection
	if err := database.TestConnection(context.Background()); err != nil {
		fmt.Printf("Failed to test database connection, error: %v", err)
		os.Exit(1)
	}
	fmt.Println("Database connection established successfully")

	if err := database.RunMigrations(context.Background()); err != nil {
		fmt.Printf("Failed to run database migrations, error: %v", err)
		os.Exit(1)
	}
	fmt.Println("Database migrations applied")

	// Create context for graceful shutdown
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()

	// Get JWT secret from environment or use default
	jwtSecret := os.Getenv("JWT_SECRET")
	if jwtSecret == "" {
		fmt.Println("Set default JWT secret")
		jwtSecret = DefaultJWTSecret
	}

	// Create HTTP server
	server := Server{
		SDB:       *database,
		JWTSecret: []byte(jwtSecret),
	}

	mux := http.NewServeMux()

	// Register routes
	mux.HandleFunc("/ping", server.Ping)
	mux.HandleFunc("/version", server.Version)
	mux.HandleFunc("/tokens", server.Tokens)
	mux.HandleFunc("/tokens/auth", server.TokensAuth)
	mux.HandleFunc("/tokens/validate", server.TokensValidate)
	mux.HandleFunc("/tokens/validate_unverified", server.TokensValidateUnverified)
	mux.HandleFunc("/tokens/usage", server.TokensUsage)
	mux.HandleFunc("/tokens/revoke", server.TokensRevoke)

	commonHandler := server.logMiddleware(mux)
	commonHandler = server.panicMiddleware(commonHandler)

	s := &http.Server{
		Addr:    fmt.Sprintf("%s:%s", serverAddr, serverPort),
		Handler: commonHandler,
	}

	go func() {
		http.ListenAndServe("localhost:6060", nil)
	}()

	// Start server in a goroutine
	go func() {
		fmt.Printf("Starting HTTP server at %s:%s\n", serverAddr, serverPort)
		if err := s.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			fmt.Printf("Server error, error: %v", err)
		}
	}()

	// Wait for shutdown signal
	<-ctx.Done()
	fmt.Println("Received shutdown signal, starting graceful shutdown")

	// Create shutdown context with timeout
	shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Gracefully close database connection
	fmt.Println("Closing database connection")
	database.Close()

	// Attempt graceful shutdown of HTTP server
	if err := s.Shutdown(shutdownCtx); err != nil {
		fmt.Printf("Server shutdown error, error: %v", err)
	} else {
		fmt.Println("Server shutdown completed successfully")
	}

	fmt.Println("Application shutdown complete")
}
