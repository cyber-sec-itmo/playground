import os
import sqlite3
import time
from contextlib import contextmanager
from datetime import datetime, timedelta
from pathlib import Path
from typing import Annotated, List, Optional
from uuid import uuid4

from fastapi import Depends, FastAPI, Form, Header, HTTPException, Request
from jose import JWTError, jwe, jwt
from pydantic import BaseModel, field_serializer

# Configuration
DEFAULT_JWT_SECRET = "00000000-0000-0000-1000-000000000000"
DEFAULT_DB_PATH = "jwtpython.sqlite"
JWT_ALGORITHM = "HS256"
JWE_SECRET = b"asecret128bitkey"  # 16 bytes for A128KW


class Token(BaseModel):
    id: str  # jti (UUID)
    is_revoked: bool
    issued_at: datetime
    expires_at: datetime
    updated_at: datetime
    client_ip: Optional[str] = None
    user_agent: Optional[str] = None
    token: Optional[str] = None  # JWT full token string (optional audit field)

    @field_serializer("issued_at", "expires_at", "updated_at")
    def serialize_datetime(self, value: datetime) -> int:
        """Serialize datetime to Unix timestamp (integer)"""
        return int(value.timestamp())


class TokenUsage(BaseModel):
    id: int
    token_id: str
    ts: datetime
    client_ip: Optional[str] = None
    user_agent: Optional[str] = None
    method: Optional[str] = None
    status: Optional[int] = None

    @field_serializer("ts")
    def serialize_datetime(self, value: datetime) -> int:
        """Serialize datetime to Unix timestamp (integer)"""
        return int(value.timestamp())


# --- DATABASE ---


class Database:
    def __init__(self, db_path: str = "jwtpython.sqlite"):
        self.db_path = db_path
        self._ensure_database()

    def _ensure_database(self):
        """Ensure database file exists and run migrations"""
        with self._get_connection() as conn:
            self._run_migrations(conn)

    @contextmanager
    def _get_connection(self):
        """Context manager for database connections"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            # Enable foreign key support
            conn.execute("PRAGMA foreign_keys = ON;")
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()

    def _run_migrations(self, conn: sqlite3.Connection):
        """Run database migrations"""
        # Create tokens table
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS tokens (
                id          TEXT PRIMARY KEY,
                is_revoked  INTEGER NOT NULL,
                issued_at   INTEGER NOT NULL,
                expires_at  INTEGER NOT NULL,
                updated_at  INTEGER NOT NULL,
                client_ip   TEXT,
                user_agent  TEXT
            );
        """
        )

        # Create token_usages table
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS token_usages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                token_id TEXT NOT NULL,
                ts INTEGER NOT NULL,
                client_ip   TEXT,
                user_agent  TEXT,
                method TEXT,
                status INTEGER,
                FOREIGN KEY (token_id) REFERENCES tokens(id) ON DELETE CASCADE
            );
        """
        )

        # Create index
        conn.execute(
            """
            CREATE INDEX IF NOT EXISTS idx_usage_token_ts 
            ON token_usages(token_id, ts);
        """
        )

        conn.commit()

    def create_token(self, token: Token) -> None:
        """Create a new token record in the database"""
        with self._get_connection() as conn:
            conn.execute(
                """
                INSERT INTO tokens (
                    id, is_revoked, issued_at, expires_at, updated_at, client_ip, user_agent
                ) VALUES (?, ?, ?, ?, ?, ?, ?);
            """,
                (
                    token.id,
                    1 if token.is_revoked else 0,
                    int(token.issued_at.timestamp()),
                    int(token.expires_at.timestamp()),
                    int(token.updated_at.timestamp()),
                    token.client_ip,
                    token.user_agent,
                ),
            )

    def get_token_by_id(self, token_id: str) -> Optional[Token]:
        """Retrieve a token by its ID from the database"""
        with self._get_connection() as conn:
            row = conn.execute(
                """
                SELECT id, is_revoked, issued_at, expires_at, updated_at, client_ip, user_agent
                FROM tokens
                WHERE id = ?
            """,
                (token_id,),
            ).fetchone()

            if row is None:
                return None

            return Token(
                id=row["id"],
                is_revoked=bool(row["is_revoked"]),
                issued_at=datetime.fromtimestamp(row["issued_at"]),
                expires_at=datetime.fromtimestamp(row["expires_at"]),
                updated_at=datetime.fromtimestamp(row["updated_at"]),
                client_ip=row["client_ip"],
                user_agent=row["user_agent"],
            )

    def list_tokens(self) -> List[Token]:
        """List all tokens from the database"""
        with self._get_connection() as conn:
            rows = conn.execute(
                """
                SELECT id, is_revoked, issued_at, expires_at, updated_at, client_ip, user_agent
                FROM tokens
                ORDER BY updated_at
            """
            ).fetchall()

            return [
                Token(
                    id=row["id"],
                    is_revoked=bool(row["is_revoked"]),
                    issued_at=datetime.fromtimestamp(row["issued_at"]),
                    expires_at=datetime.fromtimestamp(row["expires_at"]),
                    updated_at=datetime.fromtimestamp(row["updated_at"]),
                    client_ip=row["client_ip"],
                    user_agent=row["user_agent"],
                )
                for row in rows
            ]

    def revoke_token(self, token_id: str) -> Optional[Token]:
        """Mark a token as revoked in the database"""
        now = datetime.now()
        with self._get_connection() as conn:
            cursor = conn.execute(
                """
                UPDATE tokens
                SET is_revoked = 1, updated_at = ?
                WHERE id = ?
            """,
                (int(now.timestamp()), token_id),
            )

            if cursor.rowcount == 0:
                return None

            row = conn.execute(
                """
                SELECT id, is_revoked, issued_at, expires_at, updated_at, client_ip, user_agent
                FROM tokens
                WHERE id = ?
            """,
                (token_id,),
            ).fetchone()

            if row is None:
                return None

            return Token(
                id=row["id"],
                is_revoked=bool(row["is_revoked"]),
                issued_at=datetime.fromtimestamp(row["issued_at"]),
                expires_at=datetime.fromtimestamp(row["expires_at"]),
                updated_at=datetime.fromtimestamp(row["updated_at"]),
                client_ip=row["client_ip"],
                user_agent=row["user_agent"],
            )

    def create_token_usage(
        self,
        token_id: str,
        ts: datetime,
        client_ip: Optional[str] = None,
        user_agent: Optional[str] = None,
        method: Optional[str] = None,
        status: Optional[int] = None,
    ) -> None:
        """Create a new token usage record in the database"""
        with self._get_connection() as conn:
            conn.execute(
                """
                INSERT INTO token_usages (
                    token_id, ts, client_ip, user_agent, method, status
                ) VALUES (?, ?, ?, ?, ?, ?);
            """,
                (
                    token_id,
                    int(ts.timestamp()),
                    client_ip,
                    user_agent,
                    method,
                    status,
                ),
            )

    def list_token_usage(self, token_id: str) -> List[TokenUsage]:
        """Return usage events for a given token ID ordered by timestamp descending"""
        with self._get_connection() as conn:
            rows = conn.execute(
                """
                SELECT id, token_id, ts, client_ip, user_agent, method, status
                FROM token_usages
                WHERE token_id = ?
                ORDER BY ts DESC
            """,
                (token_id,),
            ).fetchall()

            return [
                TokenUsage(
                    id=row["id"],
                    token_id=row["token_id"],
                    ts=datetime.fromtimestamp(row["ts"]),
                    client_ip=row["client_ip"],
                    user_agent=row["user_agent"],
                    method=row["method"],
                    status=row["status"],
                )
                for row in rows
            ]


# --- SERVER ---

# Initialize FastAPI app
app = FastAPI(title="JWT Token Management API")


# Dependency: Get database instance
def get_database() -> Database:
    db_path = os.getenv("DATABASE_URI", DEFAULT_DB_PATH)
    return Database(db_path)


# Dependency: Get JWT secret
def get_jwt_secret() -> str:
    return os.getenv("JWT_SECRET", DEFAULT_JWT_SECRET)


# Dependency: Extract client info from request
def get_client_info(request: Request) -> tuple[str, str]:
    """Extract client IP and user agent from request"""
    # Extract IP address
    client_ip = request.headers.get("X-Forwarded-For", "")
    if not client_ip:
        client_ip = request.client.host if request.client else "unknown"
    else:
        # X-Forwarded-For can contain multiple IPs, take the first one
        client_ip = client_ip.split(",")[0].strip()

    # Extract user agent
    user_agent = request.headers.get("User-Agent", "")

    return client_ip, user_agent


# Response models
class TokenAuthResponse(Token):
    pass


class TokenValidateResponse(Token):
    pass


class JWEEncryptResponse(BaseModel):
    encrypted_token: str
    original_length: int
    encrypted_length: int
    compression_ratio: float
    processing_time: float


class JWEDecryptResponse(BaseModel):
    decrypted_payload: str
    decrypted_length: int
    processing_time: float


# JWT helper functions
def create_jwt_token(
    token_id: str,
    issued_at: datetime,
    expires_at: datetime,
    secret: str,
) -> str:
    """Create a JWT token with claims"""
    claims = {
        "jti": token_id,
        "iat": int(issued_at.timestamp()),
        "exp": int(expires_at.timestamp()),
        "nbf": int(issued_at.timestamp()),
    }
    return jwt.encode(claims, secret, algorithm=JWT_ALGORITHM)


def parse_jwt_token(token_string: str, secret: str) -> tuple[dict, str]:
    """Parse and validate JWT token, return claims and jti"""
    try:
        claims = jwt.decode(token_string, secret, algorithms=[JWT_ALGORITHM])
        jti = claims.get("jti")
        if not jti or not isinstance(jti, str):
            raise HTTPException(status_code=401, detail="Missing jti in token claims")
        return claims, jti
    except JWTError as e:
        raise HTTPException(status_code=401, detail=f"Invalid token: {str(e)}")


# Endpoints
@app.get("/ping")
async def ping() -> str:
    """Health check endpoint"""
    return "pong"


@app.post("/tokens/auth", response_model=TokenAuthResponse)
async def tokens_auth(
    request: Request,
    expires_sec: Annotated[str | None, Form()] = None,
    db: Annotated[Database, Depends(get_database)] = ...,
    jwt_secret: Annotated[str, Depends(get_jwt_secret)] = ...,
    client_info: Annotated[tuple[str, str], Depends(get_client_info)] = ...,
) -> TokenAuthResponse:
    """Create a new JWT token and store it in the database"""
    # Calculate expiration
    now = datetime.now()
    exp_duration = 24 * 60 * 60  # Default 24 hours
    if expires_sec:
        try:
            exp_duration = int(expires_sec)
        except ValueError:
            raise HTTPException(status_code=400, detail="Invalid expires_sec parameter")
    expires_at = now + timedelta(seconds=exp_duration)

    # Generate token ID
    token_id = str(uuid4())

    # Create JWT token
    token_string = create_jwt_token(token_id, now, expires_at, jwt_secret)

    # Extract client info
    client_ip, user_agent = client_info

    # Create token record
    token = Token(
        id=token_id,
        is_revoked=False,
        issued_at=now,
        expires_at=expires_at,
        updated_at=now,
        client_ip=client_ip,
        user_agent=user_agent,
        token=token_string,
    )

    # Store token in database
    db.create_token(token)

    # Record token usage (creation)
    try:
        db.create_token_usage(
            token_id=token_id,
            ts=now,
            client_ip=client_ip,
            user_agent=user_agent,
            method=request.method,
            status=201,
        )
    except Exception:
        # Don't fail the request if usage recording fails
        pass

    return TokenAuthResponse(**token.model_dump())


@app.get("/tokens/validate", response_model=TokenValidateResponse)
async def tokens_validate(
    request: Request,
    authorization: Annotated[str | None, Header()] = None,
    db: Annotated[Database, Depends(get_database)] = ...,
    jwt_secret: Annotated[str, Depends(get_jwt_secret)] = ...,
    client_info: Annotated[tuple[str, str], Depends(get_client_info)] = ...,
) -> TokenValidateResponse:
    """Validate JWT token and check revocation status"""
    # Extract token from Authorization header
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(
            status_code=400, detail="Missing or invalid Authorization header"
        )

    token_string = authorization[7:]  # Remove "Bearer " prefix

    # Parse and validate JWT token
    _, jti = parse_jwt_token(token_string, jwt_secret)

    # Check if token is revoked in database
    db_token = db.get_token_by_id(jti)
    if db_token is None:
        raise HTTPException(status_code=401, detail="Token not found")

    # Check if token is revoked
    if db_token.is_revoked:
        raise HTTPException(status_code=403, detail="Token revoked")

    # Record token usage
    client_ip, user_agent = client_info
    try:
        db.create_token_usage(
            token_id=jti,
            ts=datetime.now(),
            client_ip=client_ip,
            user_agent=user_agent,
            method=request.method,
            status=200,
        )
    except Exception:
        # Don't fail the request if usage recording fails
        pass

    # Return token with full token string
    db_token.token = token_string
    return TokenValidateResponse(**db_token.model_dump())


@app.post("/jwe/encrypt", response_model=JWEEncryptResponse)
async def jwe_encrypt(
    request: Request,
    payload: Annotated[str, Form()],
    use_compression: Annotated[bool, Form()] = False,
) -> JWEEncryptResponse:
    """
    Encrypt a payload using JWE (JSON Web Encryption).

    If use_compression is True, uses DEF compression.
    """
    if not payload:
        raise HTTPException(status_code=400, detail="Payload is required")

    start_time = time.time()

    try:
        if use_compression:
            # Use DEF compression (DEFLATE)
            encrypted_token = jwe.encrypt(
                payload, JWE_SECRET, algorithm="A128KW", zip="DEF", encryption="A128GCM"
            )
        else:
            # No compression
            encrypted_token = jwe.encrypt(
                payload, JWE_SECRET, algorithm="A128KW", encryption="A128GCM"
            )

        processing_time = time.time() - start_time
        original_length = len(payload)
        encrypted_length = len(encrypted_token)
        compression_ratio = (
            original_length / encrypted_length if encrypted_length > 0 else 0
        )

        return JWEEncryptResponse(
            encrypted_token=encrypted_token,
            original_length=original_length,
            encrypted_length=encrypted_length,
            compression_ratio=compression_ratio,
            processing_time=processing_time,
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Encryption failed: {str(e)}")


@app.post("/jwe/decrypt", response_model=JWEDecryptResponse)
async def jwe_decrypt(
    request: Request,
    encrypted_token: Annotated[str, Form()],
) -> JWEDecryptResponse:
    """
    Decrypt a JWE token.
    """
    start_time = time.time()

    try:
        decrypted_payload = jwe.decrypt(encrypted_token, JWE_SECRET)

        processing_time = time.time() - start_time
        decrypted_length = len(decrypted_payload)

        return JWEDecryptResponse(
            decrypted_payload=decrypted_payload,
            decrypted_length=decrypted_length,
            processing_time=processing_time,
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Decryption failed: {str(e)}")


# Startup event: Initialize database
@app.on_event("startup")
async def startup_event():
    """Initialize database on startup"""
    db_path = os.getenv("DATABASE_URI", DEFAULT_DB_PATH)
    db = Database(db_path)
    # Database initialization happens in __init__, migrations run automatically
    print(f"Database initialized at: {db_path}")
